\documentclass{article}
\usepackage{amsmath}

\newcommand{\tcomplex}{\textbf{Time complexity}}
\newcommand{\scomplex}{\textbf{Space complexity}}
\newcommand{\tcomplexcmp}{\textbf{Time complexity comparison}}
\newcommand{\scomplexcmp}{\textbf{Space complexity comparison}}

\newcommand{\timefn}{T}
\newcommand{\spacefn}{S}
\newcommand{\nwritesfn}{W}

\newcommand{\timenewfn}{\timefn'}
\newcommand{\spacenewfn}{\spacefn'}
\newcommand{\nwritesnewfn}{\nwritesfn'}

\newcommand{\timeratio}{r_\timefn}
\newcommand{\spaceratio}{r_\spacefn}

\newcommand{\bigo}{O}
\newcommand{\biggo}{P}
\newcommand{\varnitems}{n}

\setlength{\parskip}{1em}

\begin{document}
	\begin{abstract}
	\end{abstract}

	\section{Introduction}

	\section{Definitions}

	\section{Predefined Functions}
	
	\section{Fields and Properties}
	
	In this section, I define \textbf{fields} and \textbf{properties} on dynamic arrays and resize lists. These will be used later to implement operations on them in pseudocode.
	
	\section{Common Resize List Operations}
	
	In this section, I implement common operations for dynamic arrays, then resize lists, in pseudocode. Then, I analyze and compare the time complexities of the implementations. If the operation allocates memory, I also compare their space complexities.
	
	The following mathematical definitions will be used while analyzing time and space complexity:
	
	\begin{description}
		\item[$\biggo(f(n))$] This is an alternative to big-O notation for time complexity; I will call it \textbf{big-P notation}.
			\subitem The main purpose of big-P notation is to preserve the constant coefficient of the fastest-growing term in $f(n)$, while still maintaining many properties of big-O. For example, $\bigo(2n) = \bigo(n)$, but $\biggo(2n) \neq \biggo(n)$. This makes it possible to compare time complexities whose ratio converges to a constant as $n$ becomes larger.
			\subitem More formally, $\biggo(f(n)) = \biggo(g(n))$ iff $$\lim_{n \to \infty} {\frac{f(n)}{g(n)}} = 1$$.
	\end{description}
	
	\subsection{Adding}
	
	Adding is the most common operation done on a dynamic array\footnote{}. Resize lists improve the performance of adding in two ways: by allocating less memory, and reducing the amount of copying.
	
	% <dynamic array implementation>
	
	\tcomplex
	
	\begin{align*}
	\nwritesfn(\varnitems) = \biggo(2\varnitems)
	\end{align*}
	
	\scomplex
	
	\begin{align*}
	\spacefn(\varnitems) = \biggo(2^{\lceil \log_2 \varnitems \rceil + 1}) = \bigo(\varnitems)
	\end{align*}
	
	% <resize list implementation>
	
	\tcomplex
	
	\begin{align*}
	\nwritesnewfn(\varnitems) = \biggo(\varnitems)
	\end{align*}
	
	\scomplex
	
	\begin{align*}
	\spacenewfn(\varnitems) = \biggo(2^{\lceil \log_2 \varnitems \rceil}) = \bigo(\varnitems)
	\end{align*}
	
	\tcomplexcmp
	
	\begin{align*}
	\end{align*}
	
	\scomplexcmp
	
	\begin{align*}
	\spaceratio = \frac {\biggo(2^{\lceil \log_2 \varnitems \rceil})} {\biggo(2^{\lceil \log_2 \varnitems \rceil + 1})} = \frac{1}{2}
	\end{align*}
	
	\subsection{Indexing}
	
	% <dynamic array implementation>
	
	\tcomplex
	
	$\timefn(\varnitems) = \bigo(1)$
	
	% <resize list implementation>
	
	\tcomplex
	
	$\timenewfn(\varnitems) = \bigo(1)$
	
	\tcomplexcmp
	
	\subsection{Iterating}
	
	% <dynamic array implementation>
	
	\tcomplex
	
	$\timefn(\varnitems) = \bigo(\varnitems)$
	
	% <resize list implementation>
	
	\tcomplex
	
	$\timenewfn(\varnitems) = \bigo(\varnitems)$
	
	\tcomplexcmp
	
	\subsection{Copying to an array}
	
	\section{Other Resize List Operations}
	
	\subsection{Inserting}
	
	\subsection{Deleting}
	
	\subsection{Searching}
	
	\subsection{In-place sorting}
	
	\section{Implementations}
	
	\section{Benchmarks}
	
	\section{Closing Remarks}

\end{document}
