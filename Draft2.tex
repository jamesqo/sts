\documentclass{article}
\usepackage{amsmath}

\newcommand{\descriptn}{\textbf{Description}}
\newcommand{\dynarrayimpl}{\textbf{Dynamic array implementation}}
\newcommand{\funarrayimpl}{\textbf{Funnel array implementation}}
\newcommand{\tcomplex}{\textbf{Time complexity}}
\newcommand{\scomplex}{\textbf{Space complexity}}
\newcommand{\tcomplexcmp}{\textbf{Time complexity comparison}}
\newcommand{\scomplexcmp}{\textbf{Space complexity comparison}}

\newcommand{\timefn}{T}
\newcommand{\spacefn}{S}
\newcommand{\nwritesfn}{W}

\newcommand{\timenewfn}{\timefn'}
\newcommand{\spacenewfn}{\spacefn'}
\newcommand{\nwritesnewfn}{\nwritesfn'}

\newcommand{\timeratio}{r_\timefn}
\newcommand{\spaceratio}{r_\spacefn}

\newcommand{\bigo}{O}
\newcommand{\biggo}{P}
\newcommand{\varnitems}{n}
\newcommand{\indexertime}{I}

\newcommand{\listname}{L}

\setlength{\parskip}{1em}

\begin{document}
	\begin{abstract}
	\end{abstract}

	\section{Introduction}

	\section{Definitions}
	
	\begin{description}
		\item[decrement, increment] Decreasing or increasing (respectively) the value of an integer variable by one.
		\item[field] A variable associated with an object that may be read from or written to.\\
			It is assumed that fields can be read from and written to in constant time.
		\item[get indexer, set indexer] A method that gets or sets (respectively) an item at a specified index in a list.
		\item[indexer] Refers to a get indexer or set indexer.
		\item[property] A function of an object that returns a value, runs in constant time, and does not mutate any state (i.e. by assigning new values to fields).
		\item[trivial member] A field or property of an object.
	\end{description}

	\section{Runtime-Defined Functions}
	
	\section{Trivial Members of Dynamic and Funnel Arrays}
	
	In this section, I define \textbf{fields} and \textbf{properties} on dynamic and funnel arrays. These will be used later to implement operations on them in pseudocode.
	
	\section{Common Funnel Array Operations}
	
	In this section, I implement common operations for dynamic and funnel arrays in pseudocode. Then, I analyze and compare the time complexities of the implementations. If the operation allocates memory, I also compare their space complexities.
	
	The following mathematical definitions will be used while analyzing time and space complexity:
	
	\begin{description}
		\item[$\biggo(f(n))$] This is an alternative to big-O notation for time complexity; I will call it \textbf{big-P notation}.
			\subitem The main purpose of big-P notation is to preserve the constant coefficient of the fastest-growing term in $f(n)$, while still maintaining many properties of big-O. For example, $\bigo(2n) = \bigo(n)$, but $\biggo(2n) \neq \biggo(n)$. This makes it possible to compare time complexities whose ratio converges to a constant as $n$ becomes larger.
			\subitem More formally, $\biggo(f(n)) = \biggo(g(n))$ iff $$\lim_{n \to \infty} {\frac{f(n)}{g(n)}} = 1$$.
	\end{description}
	
	\subsection{Adding}
	
	\descriptn
	
	Adding is the most common operation done on a dynamic array\footnote{}. Funnel arrays improve the performance of adding in two ways: by allocating less memory, and reducing the amount of copying.
	
	\dynarrayimpl
	
	\tcomplex
	
	\begin{align*}
	\nwritesfn(\varnitems) = \biggo(2\varnitems)
	\end{align*}
	
	\scomplex
	
	\begin{align*}
	\spacefn(\varnitems) = \biggo(2^{\lceil \log_2 \varnitems \rceil + 1}) = \bigo(\varnitems)
	\end{align*}
	
	\funarrayimpl
	
	\tcomplex
	
	\begin{align*}
	\nwritesnewfn(\varnitems) = \biggo(\varnitems)
	\end{align*}
	
	\scomplex
	
	\begin{align*}
	\spacenewfn(\varnitems) = \biggo(2^{\lceil \log_2 \varnitems \rceil}) = \bigo(\varnitems)
	\end{align*}
	
	\tcomplexcmp
	
	\begin{align*}
	\end{align*}
	
	\scomplexcmp
	
	\begin{align*}
	\spaceratio = \frac {\biggo(2^{\lceil \log_2 \varnitems \rceil})} {\biggo(2^{\lceil \log_2 \varnitems \rceil + 1})} = \frac{1}{2}
	\end{align*}
	
	\subsection{Indexing}
	
	\descriptn
	
	Indexing is another very common operation on a list. An \textbf{indexer} gets or sets an item at a specified index in a list.
	
	\dynarrayimpl
	
	\tcomplex
	
	$\timefn(\varnitems) = \bigo(1)$
	
	% <funnel array implementation>
	
	\tcomplex
	
	$\timenewfn(\varnitems) = \bigo(1)$
	
	\tcomplexcmp
	
	\subsection{Iterating}
	
	\descriptn
	
	\textbf{Iteration} of a list is the process of performing some action on each of its elements.
	
	\dynarrayimpl
	
	\tcomplex
	
	Ignoring the arbitrary code run after getting each element, the time complexity of this method is $\bigo(\varnitems)$.
	
	\funarrayimpl
	
	\tcomplex
	
	$\timenewfn(\varnitems) = \bigo(\varnitems)$
	
	\tcomplexcmp
	
	\subsection{Copying to an array}
	
	\descriptn
	
	Users often want to take list structures, such as dynamic arrays, and convert them into plain arrays. There are multiple reasons why someone would want to do this after they are done adding to the list:
	
	\begin{itemize}
		\item Plain arrays hold on to exactly the amount of memory needed to hold their elements. However, dynamic and funnel arrays allocate more space than necessary to optimize adding new items.
		\item The user wants to call a function in third-party code that takes a plain array as an argument.
		\item
		\item Plain arrays are contiguous, while funnel arrays are fragmented and have worse locality.
		\item The indexer of funnel arrays is several times slower than that of plain arrays, whether the $\bigo(1)$ or $\bigo(\log \varnitems)$ implementation is chosen.
	\end{itemize}
	
	\dynarrayimpl
	
	\tcomplex
	
	\funarrayimpl
	
	\tcomplex
	
	\section{Other Funnel Array Operations}
	
	\subsection{Inserting}
	
	\descriptn
	
	\textbf{Inserting} an element places it at a specified index within the list, and increments the list's count. If the index equals the size of the list, the effect is the same as adding the element. Otherwise, the elements at indices greater than or equal to the specified index are moved to the next index, then the element is placed at the specified index.
	
	\subsection{Deleting}
	
	\descriptn
	
	\textbf{Deleting} the element at a specified index moves the elements at indices greater than the specified index to the previous index. The count of the list is decremented.
	
	\subsection{Searching}
	
	\descriptn
	
	\textbf{Searching} for an element returns the first or last index within the list where the item can be found. If the user knows the items of the lists are sorted, \textbf{binary search} can be used.
	
	\subsection{In-place sorting}
	
	\descriptn
	
	Given a strict ordering $<$, we say a list $\listname$ is \textbf{sorted} by $<$ iff $\left(a, b \in \listname \land a < b\right) \leftrightarrow I_M(a) < I_m(b)$. $I_M(a)$ is the last (maximum) index of $a$ in $L$, and $I_m(b)$ is the first (minimum) index of $b$ in $L$. Note that the use of $<$ on the right-hand side compares integers and not elements of $L$, so this is not a recursive definition.
	
	\section{Implementations}
	
	\section{Benchmarks}
	
	\section{Closing Remarks}

\end{document}
