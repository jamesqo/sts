\documentclass{article}
\usepackage{amsmath}

\newcommand{\descriptn}{\textbf{Description}}
\newcommand{\dynarrayimpl}{\textbf{Dynamic array implementation}}
\newcommand{\funarrayimpl}{\textbf{Funnel array implementation}}
\newcommand{\commimpltext}{Common implementation}
\newcommand{\commimpl}{\textbf{\commimpltext}}
\newcommand{\tcomplex}{\textbf{Time complexity}}
\newcommand{\scomplex}{\textbf{Space complexity}}
\newcommand{\tcomplexcmp}{\textbf{Time complexity comparison}}
\newcommand{\scomplexcmp}{\textbf{Space complexity comparison}}

\newcommand{\timefn}{T}
\newcommand{\spacefn}{S}
\newcommand{\nwritesfn}{W}

\newcommand{\timenewfn}{\timefn'}
\newcommand{\spacenewfn}{\spacefn'}
\newcommand{\nwritesnewfn}{\nwritesfn'}

\newcommand{\timeratio}{r_\timefn}
\newcommand{\spaceratio}{r_\spacefn}

\newcommand{\bigo}{O}
\newcommand{\biggo}{P}
\newcommand{\varnitems}{n}
\newcommand{\indexertime}{I}

\newcommand{\listname}{L}

\setlength{\parskip}{1em}

\begin{document}
	\begin{abstract}
	\end{abstract}

	\section{Introduction}

	\section{Definitions}
	
	\begin{description}
		\item[field] A variable associated with an object that may be read from or written to.\\
			It is assumed that fields can be read from and written to in constant time.
		\item[get indexer] A method that gets an item at a specified index in a list.
		\item[indexer] Refers to a get indexer or set indexer.
		\item[property] A function of an object that returns a value, runs in constant time, and does not mutate any state (i.e. by assigning new values to fields).
		\item[set indexer] A method that sets an item at a specified index in a list.
		\item[trivial member] A field or property of an object.
	\end{description}

	\section{Predefined Functions}
	
	\section{Trivial Members}
	
	In this section, I define \textbf{fields} and \textbf{properties} on dynamic and funnel arrays. These will be used later to implement operations on them in pseudocode.
	
	\section{Common Funnel Array Operations}
	
	In this section, I implement common operations for dynamic and funnel arrays in pseudocode. Then, I analyze and compare the time complexities of the implementations. If the operation allocates memory, I also compare their space complexities.
	
	The following mathematical definitions will be used while analyzing time and space complexity:
	
	\begin{description}
		\item[$\biggo(f(n))$] This is an alternative to big-O notation for time complexity; I will call it \textbf{big-P notation}.
			\subitem The main purpose of big-P notation is to preserve the constant coefficient of the fastest-growing term in $f(n)$, while still maintaining many properties of big-O. For example, $\bigo(2n) = \bigo(n)$, but $\biggo(2n) \neq \biggo(n)$. This makes it possible to compare time complexities whose ratio converges to a constant as $n$ becomes larger.
			\subitem More formally, $\biggo(f(n)) = \biggo(g(n))$ iff $$\lim_{n \to \infty} {\frac{f(n)}{g(n)}} = 1$$.
	\end{description}
	
	\subsection{Adding}
	
	\descriptn
	
	Adding is the most common operation done on a dynamic array\footnote{}. Funnel arrays improve the performance of adding in two ways: by allocating less memory, and reducing the amount of copying.
	
	\dynarrayimpl
	
	\tcomplex
	
	\begin{align*}
	\nwritesfn(\varnitems) = \biggo(2\varnitems)
	\end{align*}
	
	\scomplex
	
	\begin{align*}
	\spacefn(\varnitems) = \biggo(2^{\lceil \log_2 \varnitems \rceil + 1}) = \bigo(\varnitems)
	\end{align*}
	
	\funarrayimpl
	
	\tcomplex
	
	\begin{align*}
	\nwritesnewfn(\varnitems) = \biggo(\varnitems)
	\end{align*}
	
	\scomplex
	
	\begin{align*}
	\spacenewfn(\varnitems) = \biggo(2^{\lceil \log_2 \varnitems \rceil}) = \bigo(\varnitems)
	\end{align*}
	
	\tcomplexcmp
	
	\begin{align*}
	\end{align*}
	
	\scomplexcmp
	
	\begin{align*}
	\spaceratio = \frac {\biggo(2^{\lceil \log_2 \varnitems \rceil})} {\biggo(2^{\lceil \log_2 \varnitems \rceil + 1})} = \frac{1}{2}
	\end{align*}
	
	\subsection{Indexing}
	
	\descriptn
	
	Indexing is another very common operation on a list. An \textbf{indexer} gets or sets an item at a specified index in a list.
	
	\dynarrayimpl
	
	\tcomplex
	
	$\timefn(\varnitems) = \bigo(1)$
	
	% <funnel array implementation>
	
	\tcomplex
	
	$\timenewfn(\varnitems) = \bigo(1)$
	
	For the rest of this paper, I will not assume the indexer's time complexity is $\bigo(1)$ nor $\bigo(\log \varnitems)$. Instead, I will denote it by the function $\indexertime(\varnitems)$, where $\indexertime(\varnitems)$ is either $1$ or $\log \varnitems$.
	
	Since many list operations I detail can be implemented using the indexer in a loop, I make the following useful claim:
	
	Let $\listname$ be a list. Suppose $LC$ is a loop construct that runs $N$ times, where $N$ is a fixed number. If the body of the loop contains only the indexer of $\listname$ and statements that run in constant time, and the loop does not contain nested loops, then the time complexity of the loop is $\bigo(N \cdot \indexertime(\varnitems))$.
	
	To see this, note that the time complexity of the body of the loop is $\bigo(\indexertime(\varnitems)) + \bigo(1) = \bigo(\indexertime(\varnitems))$. Since the body is run $N$ times, the total time complexity is $N \cdot \bigo(\indexertime(\varnitems)) = \bigo(N \cdot \indexertime(\varnitems))$.
	
	\tcomplexcmp
	
	\subsection{Iterating}
	
	\descriptn
	
	\textbf{Iteration} of a list is the process of performing some action on each of its elements. The standard implementation of iteration for dynamic arrays is also applicable to funnel arrays. When this happens in this and subsequent sections, the second heading will be titled "\commimpltext".
	
	\commimpl
	
	\tcomplex
	
	By , the time complexity of this operation is $\bigo(\varnitems)$ for dynamic arrays.
	
	By , the time complexity of this operation is $\bigo(\varnitems \cdot \indexertime(\varnitems))$ for funnel arrays. However, I demonstrate an alternative implementation for funnel arrays below that is $\bigo(\varnitems)$ independent of $\indexertime(\varnitems)$:
	
	\funarrayimpl
	
	
	
	\tcomplex
	
	$\timenewfn(\varnitems) = \bigo(\varnitems)$
	
	\tcomplexcmp
	
	\subsection{Copying to an array}
	
	\section{Other Funnel Array Operations}
	
	\subsection{Inserting}
	
	\subsection{Deleting}
	
	\subsection{Searching}
	
	\subsection{In-place sorting}
	
	\section{Implementations}
	
	\section{Benchmarks}
	
	\section{Closing Remarks}

\end{document}
