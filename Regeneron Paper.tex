\documentclass{article}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{blindtext}
\usepackage{enumitem}
\usepackage{hyperref}

\algnewcommand{\LineComment}[1]{
	\State \(\triangleright\) #1
}

\algrenewcommand
\textproc{}

\hypersetup{
	colorlinks=true,
	linkcolor=blue
}

\setlist{nolistsep}
\setlength{\parskip}{1em}

\begin{document}
	\begin{abstract}
		This paper introduces the \textit{fragmented list} data structure, which implements the list abstract data type. A fragmented list consists of multiple arrays, or \textit{buffers}, that store its elements. Fragmented lists do not make copies or throw away old buffers while resizing. As a result, they perform significantly better than dynamic arrays when a large number of elements are added to them. However, this is provided the final size of the list (or a close upper bound on it) is not known beforehand. If it is, a buffer of that size can be pre-allocated and resizing can be avoided, making fragmented lists redundant.
	\end{abstract}

	\section{Introduction}
	\label{Introduction}
	
	% TODO: This isn't being indented
	Often, node-based structures receive the most attention in a course on data structures. Although it is simpler to implement everything with arrays\footnote{}, node-based structures are favored because they have better time complexity for operations such as insertion and deletion.\par

	However, arrays have their own performance advantages over such structures, including:\par
	
	\begin{itemize}
		\item Better locality when iterating: elements of an array live next to each other in memory.
		\item Less memory overhead: memory does not need to be allocated for nodes.
		\item Fast random access: since arrays are just pointers, indexing them takes a few instructions and runs in $O(1)$ time.
	\end{itemize}

	When an abstract data type (which I will refer to as \textit{data type}) can be implemented easily with arrays, they are often used. One such data type is the \textit{list}\footnote{}, which is usually implemented with a dynamic array.\par

	Dynamic arrays perform reasonably well with respect to their most common operations. Adding an item runs in amortized $O(1)$ time, indexing them runs in $O(1)$ time, and they can be iterated in $O(n)$ time.\par
	
	However, when a dynamic array is \textit{full} (that is, its size equals its capacity) and an item is added, it must resize its buffer to fit the new item. Its behavior here is less than optimal: it allocates a new buffer larger than the current one, copies over the items, and discards the current buffer.\par
	
	Instead of throwing away buffers once they're filled up, \textit{fragmented lists} store references to them in a two-dimensional array. During a resize, a new buffer is still allocated; however, for a sufficiently large number of items, it is always half the size of the buffer that a dynamic array would allocate.\par
	
	In addition, no items are copied to the front of the new buffer. This is because no buffer represents the entire content of the list; each buffer holds just a \textit{fragment} of the items. To get back the items that were added to the fragmented list, one needs to traverse each of the buffers and copy their share of the items.\par
	
	% TODO: ToC or not?

	\section{Terminology}
	\label{Terminology}
	
	\begin{description}
		\item[buffer] % TODO
		\item[capacity] % TODO
		\item[full/filled] % TODO
		\item[growth factor]
		\item[list] % TODO
		\item[resize]
		\item[threshold sizes] The set of sizes for which adding one more item will cause the list to resize. This is the same as the set of all capacities the list takes on. [prove]
	\end{description}

	\section{Predefined Functions}
	\label{Predefined Functions}
	
	I assume the following functions are provided by the runtime environment, so that I may use them without defining them beforehand.\par
	
	\begin{algorithm}\begin{algorithmic}
			\LineComment{Adds \textit{item} to dynamic array \textit{dynamic}}
			\State $add_{dyn}(dynamic, item)$
			\\
			\LineComment{Allocates and returns an array of length \textit{len}}
			\State $array(len)$
			\\
			\LineComment{Returns the length of array \textit{array}}
			\State $len(array)$
		\end{algorithmic}\end{algorithm}
	
	\section{Fragmented List Structure}
	\label{Fragmented List Structure}

	Each fragmented list, denoted by $\ell$, is given four \textit{fields}: $h(\ell)$, $t(\ell)$, $size(\ell)$, and $hsize(\ell)$. These fields may be read from and assigned to.\par
	
	\begin{itemize}
		\item $h$ stands for the \textit{head} of the fragmented list. It returns the buffer we are currently adding items to.
		\item $t$ stands for the \textit{tail} of the list. It returns a list of buffers that have already been filled.
		\item $size$ returns the number of items in $\ell$.
		\item $hsize$ stands for \textit{head size}. It returns the number of items in $h(\ell)$. This is \textit{not} the same as $len(h(\ell))$; that is the head's capacity.
	\end{itemize}
	
	Below, I also define some auxiliary functions on $\ell$ (which cannot be assigned to). $:=$ denotes a definition, as opposed to $=$ which checks equivalence. Functions that return boolean values are suffixed with ?.
	
	\begin{algorithm}\begin{algorithmic}
			\LineComment{Returns the capacity of $\ell$}
			\State $cap(\ell) := size(\ell) + \left(hcap(\ell) - hsize(\ell)\right)$
			\\
			\LineComment{Returns whether $\ell$ is empty}
			\State $empty?(\ell) := size(\ell) = 0$
			\\
			\LineComment{Returns whether $\ell$ is full}
			\State $full?(\ell) := size(\ell) = cap(\ell)$
			\\
			\LineComment{Returns the capacity of $h(\ell)$}
			\State $hcap(\ell) := len(h(\ell))$
		\end{algorithmic}\end{algorithm}
	
	\section{Fragmented List Operations}
	\label{Fragmented List Operations}
	
	\subsection{Adding an Element}
	
	I begin with the implementation for \textit{add} since it is the most common list operation [cite]. Its algorithm is very similar to that of a dynamic array: it resizes the list if it's full, then stores the item and increments the size. The head's size is also incremented since an item is added to it.
	
	\begin{algorithm}\begin{algorithmic}[1]
			\Procedure{\textit{add}}{$\ell, item$}
				\If{$full?(\ell)$}
					\State $resize(\ell)$
				\EndIf
				
				\State $h(\ell)[hsize(\ell)] \gets item$
				\State $size(\ell) \gets size(\ell) + 1$
				\State $hsize(\ell) \gets hsize(\ell) + 1$
			\EndProcedure
		\end{algorithmic}\end{algorithm}
	
	A fragmented list is resized quite a bit differently from a dynamic array, however. % TODO
	
	\begin{algorithm}\begin{algorithmic}[1]
			\Procedure{\textit{resize}}{$\ell$}
				\Require
					\Statex $full?(\ell)$
				\If{$empty?(\ell)$}
					\State $h(\ell) \gets array(4)$
					\State $cap(\ell) \gets 4$
					\State \Return
				\EndIf
			
				\State $add_{dyn}(tail(\ell), head(\ell))$
				\State $newcap \gets g(hcap(\ell))$
				\State $h(\ell) \gets array(newcap)$
				\State $hsize(\ell) \gets 0$
				\State $cap(\ell) \gets cap(\ell) + newcap$
			\EndProcedure
		\end{algorithmic}\end{algorithm}
	
	\begin{algorithm}\begin{algorithmic}[1]
			\LineComment{\textit{g} is the \textit{growth function}.}
			\LineComment{It decides the capacity of the next buffer based on the current buffer's capacity.}
			\Function{\textit{g}}{$cap$}
			\Require
			\Statex $cap \geq 4 \land \log_2{cap} \in \mathbb{N}$
			\State \Return $\begin{cases}
			4 & cap = 4\\
			2 * cap & cap \neq 4
			\end{cases}$
			\EndFunction
		\end{algorithmic}\end{algorithm}
	
	\subsubsection{Time Analysis}
	
	$$
	T[add] = T_{2,6} = T_{2,3} + T_{4, 6}
	$$
	
	When $\ell$ is not full:
	
	$$
	T_{2,3} + T_{4,6} = T_{4,6} = C
	$$
	
	When $\ell$ is full:
	
	$$
	T_{2,3} + T_{4,6} = T_[full?] + T_[resize] + T_{4,6} = T[resize] + C
	$$
	
	Now we must analyze $resize$.
	
	When $\ell$ is empty:
	
	$$
	T[resize] = T_{2,5} = T[empty?] + T_alloc(4) + T_5 = T_alloc(4) + C
	$$
	
	When $\ell$ is non-empty:
	
	$$
	T[resize] = T[empty?] + 
	$$
	
	\subsubsection{Space Analysis}
	
	\subsection{Indexing}
	
	\begin{algorithm}\begin{algorithmic}[1]
			\Function{\textit{item at index}}{$\ell, index$}
	 			\Require
	 				\Statex $0 \leq index < size(\ell)$
	 			\State $i \gets index$
	 			\ForAll{$buf \in t(\ell)$}
	 				\If{$i < len(buf)$}
	 					\State \Return $buf[i]$
	 				\EndIf
	 				\State $i \gets i - len(buf)$
	 			\EndFor
	 			
	 			\Return $h(\ell)[i]$
 			\EndFunction
		\end{algorithmic}\end{algorithm}

	A function to set an item at a particular index can be implemented in a similar fashion.
	
	\subsection{Inserting an Element}
	
	\subsection{Deleting the Last Element}
	
	\subsection{Deleting an Element}
	
	\subsection{Copying to an Array}
	
	\subsection{Iterating}
	
	\subsection{Searching}
	
	\subsection{In-Place Sorting}
	
	\section{Implementations}
	\label{Implementations}
	
	\section{Benchmarks}
	\label{Benchmarks}
	
	\section{Closing Remarks}
	\label{Closing Remarks}
	
	% TODO: May need to ask something about how the pseudocode is only valid for GC'd languages.

\end{document}
