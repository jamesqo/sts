\HdrGrowthArrayImpl

\HdrTimeComplex

I again start off by finding the write cost for $n$ items. I will denote mathematical variables and functions associated with growth arrays with a hat on top, to avoid confusion with their dynamic array counterparts. For example, $\FuncWritesNew(n)$ will denote growth arrays' write cost function, $\VarInitCapacityNew$ their initial capacity, $\VarGrowthFactorNew$ their growth factor, and so on.

\ref{lem:CapacitySeq} still holds, since all of the assumptions made there still hold for growth arrays. In particular, although growth arrays use a different growth algorithm than dynamic arrays, the following claim is still true:

\begin{lemma}
	The capacity of a non-empty growth array grows by the constant factor $\VarGrowthFactorNew$.
\end{lemma}

\begin{proof}
	I prove that the $\FuncGrow$ algorithm always enforces this using induction. I induct on the number of times $\FuncGrow$ is called, $k$, showing that for all $k \geq 2$, $\FuncGrow$ behaves correctly when called the $k$th time. (At $k = 1$, the growth array is empty, so its behavior is not relevant to this lemma.) I will let $c_i$ and $c_f$ denote the initial and final capacities and $h_i$ and $h_f$ denote the initial and final head capacities for the $k$th call, respectively.

	At $k = 2$, $c_i = \VarInitCapacityNew$. I wish to show that $c_f = \VarGrowthFactorNew\VarInitCapacityNew$. This happens if and only if the next buffer has size $\Delta c = (\VarGrowthFactorNew - 1)\VarInitCapacityNew$, which the algorithm ensures.
	
	For $k > 2$, by induction $c_i = \VarGrowthFactorNew^{k - 2}\VarInitCapacityNew$ and $h_i = (\VarGrowthFactorNew^{k - 2} - \VarGrowthFactorNew^{k - 3})\VarInitCapacityNew$. I wish to show $c_f = \VarGrowthFactorNew^{k - 1}\VarInitCapacityNew$ and $h_f = (\VarGrowthFactorNew^{k - 1} - \VarGrowthFactorNew^{k - 2})\VarInitCapacityNew$. Because $k > 2$, the algorithm will calculate $h_f$ as $\VarGrowthFactorNew$ times $h_i$. Then $h_f = \VarGrowthFactorNew h_i = \VarGrowthFactorNew (\VarGrowthFactorNew^{k - 2} - \VarGrowthFactorNew^{k - 3})\VarInitCapacityNew = (\VarGrowthFactorNew^{k - 1} - \VarGrowthFactorNew^{k - 2})\VarInitCapacityNew$ as desired, and $c_f = c_i + h_f = \VarGrowthFactorNew^{k - 2}\VarInitCapacityNew + (\VarGrowthFactorNew^{k - 1} - \VarGrowthFactorNew^{k - 2})\VarInitCapacityNew = \VarGrowthFactorNew^{k - 1}\VarInitCapacityNew$, concluding the proof.
\end{proof}

% Bookmark

Now I take a look at $\FuncGrow$. Unlike dynamic arrays, the number of writes performed does not equal $i$ if the current size is $i$. No items are being copied; the only source of writes is appending a buffer to the tail. The goal is to find the number of writes that causes.

Let $\FuncWritesByGrow(n)$ denote the total number of writes made by $\FuncGrow$. From [make lemma], I know that $\FuncGrow$ is called at the sizes

\begin{align*}
S_R = 0,\ \VarInitCapacityNew,\ \VarGrowthFactorNew\VarInitCapacityNew,\ \VarGrowthFactorNew^2\VarInitCapacityNew,\ \ldots\ \VarGrowthFactorNew^{\lceil \log_{\VarGrowthFactorNew} n - \log_{\VarGrowthFactorNew} \VarInitCapacityNew \rceil - 1}\VarInitCapacityNew
\end{align*}

Let $k$ be the number of times the tail is appended to. Since the tail is a dynamic array, the number of writes it makes is $\FuncWrites(k)$. Since $\FuncGrow$ is called $|S_R|$ times and it appends to the tail each time except for the first, $k = |S_R| - 1 = \lceil \log_{\VarGrowthFactorNew} n - \log_{\VarGrowthFactorNew} \VarInitCapacityNew \rceil$. Then the formula for $\FuncWritesByGrow(n)$ is

\begin{align*}
\FuncWritesByGrow(n) = k + \left( \frac{\VarGrowthFactor^{\lceil \log_{\VarGrowthFactor} k - \log_{\VarGrowthFactor} \VarInitCapacity \rceil} - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity
\end{align*}

where $\VarInitCapacity$ $\VarGrowthFactor$ are the capacity of the \textit{tail} (not the growth array). I finally conclude that

\begin{align*}
\FuncWritesNew(n) = n + k + \left( \frac{\VarGrowthFactor^{\lceil \log_{\VarGrowthFactor} k - \log_{\VarGrowthFactor} \VarInitCapacity \rceil} - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity
\end{align*}

I now approximate this expression using $\sim$. First, I approximate $k$ using big-O:

\begin{align*}
k &= \lceil \log_{\VarGrowthFactorNew} n - \log_{\VarGrowthFactorNew} \VarInitCapacityNew \rceil\\
O(k) &= O(\log n)
\end{align*}

Now, the $k$-term disappears when using $\sim$ to approximate $\FuncWritesNew(n)$, leaving just $n$:

\begin{align*}
\FuncWritesNew(n) &\sim n + \FuncWrites(k)\\
&= n + O(\log n)\\
&\sim n
\end{align*}

\HdrSpaceComplex

% Should this be C(n) instead of C?
The space function for $n$ $\FuncAppend$ calls on a growth array is denoted $\FuncSpaceNew(n)$. Since growth arrays never throw away item buffers, if the current capacity is $C$ then the total length of item buffers is also $C$. $\FuncSpaceNew(n)$ is usually greater than $C$, however; this is because growth arrays not only allocate item buffers, but stores references to them in the tail. Thus the space the tail allocates must also be determined.

I determined in [...] that if $n$ are appended then the tail is appended to $k$ times, where $k = \lceil \log_{\VarGrowthFactorNew} n - \log_{\VarGrowthFactorNew} \VarInitCapacityNew \rceil$. Since the tail is a dynamic array, it allocates $\FuncSpace(k)$ space, where $\FuncSpace$ is the space function of the tail. Through a similar method to [...] it can be shown $O(\FuncSpace(k)) = O(k) = O(\log n)$. Then % TODO: P-analysis should come after the explicit formula.

\begin{align*}
\FuncSpaceNew(n) \sim 2^{\lceil \log_2 n \rceil} = O(n)
\end{align*}