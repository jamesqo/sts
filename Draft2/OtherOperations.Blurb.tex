Growth arrays support other dynamic array operations, such as insertion/deletion at an index, binary search, sorting, etc. I will not give algorithms for these operations in this paper, since they are not as common as the four detailed above. However, I will briefly describe how insertion and deletion can be implemented.

Suppose the user wants to insert an item at index $i$. If $i = n$, then simply append the item. Otherwise ($0 \leq i < n$), capture $\VarList[n - 1]$ in a local variable. Shift all elements with index $\geq i$ forward by one, so that their index increases by one. Append the original value of $\VarList[n - 1]$. Finally, set index $i$ to the provided item.

Suppose the user wants to delete the item at index $i$. Shift all elements with index $> i$ backwards by one, so that their index decreases by one. Decrement $\VarList.\FieldSize$ and $\VarList.\FieldHeadSize$. If this causes $\VarList.\FieldHeadSize$ to become $0$ and $\VarNumPointersTail > 0$, then discard the head and replace it with the last buffer pointed to by the tail. Remove this buffer from the tail.