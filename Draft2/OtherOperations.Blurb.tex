Growth arrays support other dynamic array operations, such as insertion or deletion at an index, binary search, sorting, etc. I will not give algorithms for these operations in this paper, since they are not as common as the four detailed above. However, I will briefly describe how insertion and deletion can be implemented.

Suppose the user wants to insert an item at index $i$. If $i = n$, then simply append the item. If $0 \leq i < n$: capture $\VarList[n - 1]$ in a local variable. Shift all elements with index $\geq i$ forward, such that their index increases by $1$. Append the original value of $\VarList[n - 1]$. Finally, store the provided item at index $i$.

Suppose the user wants to delete the item at index $i$. Shift all elements with index $> i$ backwards, such that their index decreases by one. (This will overwrite the item at index $i$.) Decrement $\VarList.\FieldSize$ and $\VarList.\FieldHeadSize$. If this causes $\VarList.\FieldHeadSize$ to become $0$ and currently $\VarList.\FieldTail.\FieldSize > 0$, then discard the head and replace it with the last buffer pointed to by the tail. Remove this buffer from the tail.