\HdrGrowthArrayImpl

Indexing a growth array is slower and more complex than indexing a dynamic array. However, this does not mean that accessing data of a growth array has to be slower than accessing that of a dynamic array. Refer to Sections [Iterating] and [Copying to an array] to learn how to quickly access growth arrays' data.

Despite growth arrays' relatively poor indexing performance, I include this section for two reasons. 1) Dynamic arrays are indexed frequently. In order for growth arrays to be a viable replacement for them, it should be possible to index growth arrays too. 2) I wish to show that it is possible to index growth arrays in constant time.

\HdrLogarithmicImpl

The first algorithm I will demonstrate is a na\"{i}ve implementation that runs in logarithmic time:

\begin{algorithm}
	\begin{algorithmic}
		\Function{$\FuncGetItem$}{$\VarList,\ \ParamIndex$}
			\State $\LclIndex \gets \ParamIndex$
			\For{$\LclBuffer \TextIn \VarList.\FieldTail$}
				\If{$\LclIndex < \LclBuffer.\FieldLength$}
					\State \Return $\LclBuffer[\LclIndex]$
				\EndIf
				\State $\LclIndex \gets \LclIndex - \LclBuffer.\FieldLength$
			\EndFor
			\State \Return $\VarList.\FieldHead[\LclIndex]$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

I know that this algorithm runs in $O(\log n)$ time since it was shown earlier that the size of the tail, $\VarNumItemsTail$, equals $\VarUseful$, and (from Lemma \ref{lem:VarUsefulIsOLogN}) that $\VarUseful = O(\log n)$. Aside from iteration over the tail, all statements run in constant time.

I present this algorithm alongside the constant time one because it is easier to understand, and the latter is often slower if special circumstances are not met.

\HdrConstantImpl

In this section, I will present a constant time algorithm for indexing a growth array. Before I do so, however, I must establish a mathematical justification for it.

Suppose I want to get the $i$th element of a growth array, where $i$ is zero-based. I assume that $i$ is a valid index, or that $0 \leq i < \VarList.\FieldSize$. In order to locate the desired element, I must find two things: the buffer that holds the item, and the index of the item within that buffer.

Now, consider that every buffer except the head is stored inside the tail. Thus, such buffers can be uniquely identified by their index in the tail. I will refer to this quantity as the \textbf{buffer index} and denote it $\VarIndexBuffer$. I wish to assign the head a buffer index as well, so that each buffer has a unique ID. Since the head succeeds the tail's last buffer, which has $\VarIndexBuffer = \VarNumItemsTail - 1$, I will let the head's $\VarIndexBuffer$ be $\VarNumItemsTail$.

I define a helper function, $\FuncGetBuffer$, that gets the buffer associated with a given $\VarIndexBuffer$. $\VarIndexBuffer$ is assumed to be valid; that is, $0 \leq \VarIndexBuffer \leq \VarNumItemsTail$.

% Todo: Make parameter names for other parts consistent.
\begin{algorithm}
	\begin{algorithmic}
		\Function{$\FuncGetBuffer$}{$\VarList,\ \LclIndexBuffer$}
			\If{$\LclIndexBuffer < \VarList.\FieldTail.\FieldSize$}
				\State \Return $\VarList.\FieldTail[\LclIndexBuffer]$
			\Else
				\State \Return $\VarList.\FieldHead$
			\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}

I will call the index of the desired element within the buffer the \textbf{element index}, and denote it $\VarIndexElement$.

If I define a helper function $\FuncDecompose$ that returns the $\VarIndexBuffer$ and $\VarIndexElement$ associated with $i$ in an ordered pair, then $\FuncGetItem$ may be written as follows:

\begin{algorithm}
	\begin{algorithmic}
		\Function{$\FuncGetItem$}{$\VarList,\ \ParamIndex$}
			\State $(\LclIndexBuffer,\ \LclIndexElement) \gets \FuncDecompose(\ParamIndex)$
			\State \Return $\VarList.\FuncGetBuffer(\LclIndexBuffer)[\LclIndexElement]$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

% Todo: \VarLogicalIndex for i? Introduce "logical index" term above?
The task is now to find formulae for $\VarIndexBuffer$ and $\VarIndexElement$ in terms of $i$, in order to implement $\FuncDecompose$.

% Todo: There's an awful lot of lemmas. Make some into theorems.
\begin{lemma}
	The formulae for $\VarIndexBuffer$ and $\VarIndexElement$ are
	\begin{align*}
	\VarIndexBuffer &= \VarUseful|_{n = i + 1}\\
	\VarIndexElement &= i - \VarGrowSeq_{\VarIndexBuffer - 1}
	\end{align*}
\end{lemma}

% Todo: "As shown earlier"
% Todo: Again, by convention \VarGrowSeq_{-1} = 0. Modify the algorithm accordingly.
\begin{proof}
	Appending new items does not change the index of an item that is already in the list. Thus, this problem can be reduced to finding the last element when $n = i + 1$.
	
	The last element always resides in the head, so $\VarIndexBuffer = \VarNumItemsTail|_{n = i + 1}$. As shown earlier, $\VarNumItemsTail = \VarUseful$, so $\VarIndexBuffer = \VarUseful|_{n = i + 1}$.
	
	To find $\VarIndexElement$, consider the equation:
	\begin{align*}
	n = \text{\# of items in tail} + \text{\# of items in head}
	\end{align*}
	From the premise, $n = i + 1$. The number of items in the tail is the last size at which $\FuncGrow$ was called, or $\VarGrowSeq_{\VarUseful - 1} = \VarGrowSeq_{\VarIndexBuffer - 1} = \text{the last term of } \VarGrowSeq$. Finally, since the desired item is the last item in the growth array, it is also the last item in the head. Thus $\VarIndexElement$ is the head's last valid index, so the size of the head is $\VarIndexElement + 1$. Substituting these values into the above equation, I receive
	\begin{align*}
	i + 1 &= \VarGrowSeq_{\VarIndexBuffer - 1} + \VarIndexElement + 1\\
	\VarIndexElement &= i - \VarGrowSeq_{\VarIndexBuffer - 1}
	\end{align*}
	completing the proof.
\end{proof}

% Todo: Mention formulae for \VarUseful and \VarGrowSeq_{\VarIndexBuffer - 1}.
Now, the $\FuncDecompose$ function can be implemented as follows:

% Todo: Continue to consider usage of mathematical vs. algorithm vars.
% Todo: Can ceiling of \log_2 be implemented fast? Also, what if \VarInitCapacity is not a power of 2?
\begin{algorithm}
	\begin{algorithmic}
		\Function{$\FuncDecompose$}{$\ParamIndex$}
			\State $\LclIndexBuffer \gets \max(\left\lceil \log_{\VarGrowthFactor} (\ParamIndex + 1) - \log_{\VarGrowthFactor} \VarInitCapacity \right\rceil, 0)$
			\State $\LclIndexElement \gets \ParamIndex - \VarGrowthFactor^{\LclIndexBuffer - 1} \times \VarInitCapacity$
			\State \Return $(\LclIndexBuffer,\ \LclIndexElement)$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Clearly, $\FuncDecompose$ runs in constant time. Despite that, it still appears to be quite expensive: normally, logarithms and exponentiation utilize costly floating-point instructions. However, in the special case where $\VarGrowthFactor = 2$ and $\VarInitCapacity = 2^\VarLogInitCapacity$ for some constant whole number $\VarLogInitCapacity$, I claim that $\VarIndexBuffer$ and $\VarIndexElement$ can be computed without use of floating-point instructions.

To see this, first note that $\VarIndexBuffer$ becomes $\max(\left\lceil \log_2 (i + 1) \right\rceil - \VarLogInitCapacity, 0)$. There is a constant time algorithm for computing $\left\lceil \log_2 k \right\rceil$ for any $k \in \mathbb{N}$, which uses bitwise operations instead of floating-point instructions. (I will not discuss it in this paper due to the length its mathematical justification would require, but the algorithm may be found in [Implementations section].) Thus $\left\lceil \log_2 (i + 1) \right\rceil$ can be computed without floating-point instructions. It is easy to see that the rest of the expression for $\VarIndexBuffer$ can be computed without them, too, proving the claim for $\VarIndexBuffer$.

The expression for $\VarIndexElement$ becomes $i - 2^{\VarIndexBuffer + \VarLogInitCapacity - 1}$. Since $\VarIndexBuffer$ has already been found, it is trivial to compute $\VarIndexBuffer + \VarLogInitCapacity - 1$. $2$ raised to this power can be computed cheaply with a bit shift. Finally, subtracting from $i$ does not use floating-point instructions, proving the claim for $\VarIndexElement$.