\HdrGrowthArrayImpl

Indexing a growth array is slower and more complex than indexing a dynamic array. However, this does not mean that accessing data of a growth array has to be slower than accessing that of a dynamic array. Refer to Sections [Iterating] and [Copying to an array] to learn how to quickly access growth arrays' data.

Despite growth arrays' relatively poor indexing performance, I include this section for two reasons. 1) Dynamic arrays are indexed frequently. In order for growth arrays to be a viable replacement for them, it should be possible to index growth arrays too. 2) I wish to show that it is possible to index growth arrays in constant time.

\HdrLogarithmicImpl

The first algorithm I will demonstrate is a na\"{i}ve implementation that runs in logarithmic time:

\begin{algorithm}
	\begin{algorithmic}
		\Function{$\FuncGetItem$}{$\VarList,\ \ParamIndex$}
			\State $\LclIndex \gets \ParamIndex$
			\For{$\LclBuffer \TextIn \VarList.\FieldTail$}
				\If{$\LclIndex < \LclBuffer.\FieldLength$}
					\State \Return $\LclBuffer[\LclIndex]$
				\EndIf
				\State $\LclIndex \gets \LclIndex - \LclBuffer.\FieldLength$
			\EndFor
			\State \Return $\VarList.\FieldHead[\LclIndex]$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

I know that this algorithm runs in $O(\log n)$ time since it was shown earlier that the size of the tail, $\VarNumItemsTail$, equals $\VarUseful$, and (from Lemma \ref{lem:VarUsefulIsOLogN}) that $\VarUseful = O(\log n)$. Aside from iteration over the tail, all statements run in constant time.

I present this algorithm alongside the constant time one because it is easier to understand, and the latter is often slower if special circumstances are not met.

\HdrConstantImpl

In this section, I will present a constant time algorithm for indexing a growth array. Before I do so, however, I must establish a mathematical justification for it.

Suppose I want to get the $i$th element of a growth array, where $i$ is zero-based. I assume that $i$ is a valid index, or that $0 \leq i < \VarList.\FieldSize$. In order to locate the desired element, I must find two things: the buffer that holds the item, and the index of the item within that buffer.

Now, consider that every buffer except the head is stored inside the tail. Thus, such buffers can be uniquely identified by their index in the tail. I will refer to this quantity as the \textbf{buffer index} and denote it $\VarIndexBuffer$. I wish to assign the head a buffer index as well, so that each buffer has a unique ID. Since the head succeeds the tail's last buffer, which has $\VarIndexBuffer = \VarNumItemsTail - 1$, I will let the head's $\VarIndexBuffer$ be $\VarNumItemsTail$.

I define a helper function, $\FuncGetBuffer$, that gets the buffer associated with a given $\VarIndexBuffer$:

% Todo: Make parameter names for other parts consistent.
\begin{algorithm}
	\begin{algorithmic}
		\Function{$\FuncGetBuffer$}{$\VarList,\ \ParamIndexBuffer$}
			\If{$\ParamIndexBuffer < \VarList.\FieldTail.\FieldSize$}
				\State \Return $\VarList.\FieldTail[\ParamIndexBuffer]$
			\Else
				\State \Return $\VarList.\FieldHead$
			\EndIf
		\EndFunction
	\end{algorithmic}
\end{algorithm}

I will call the index of the desired element within the buffer the \textbf{element index}, and denote it $\VarIndexElement$.

If I define a helper function $\FuncDecompose$ that returns the $\VarIndexBuffer$ and $\VarIndexElement$ associated with $i$ in an ordered pair, then $\FuncGetItem$ may be written as follows:

\begin{algorithm}
	\begin{algorithmic}
		\Function{$\FuncGetItem$}{$\VarList,\ \ParamIndex$}
			\State $(\VarIndexBuffer,\ \VarIndexElement) \gets \FuncDecompose(\ParamIndex)$
			\State \Return $\VarList.\FuncGetBuffer(\ParamIndexBuffer)[\ParamIndexElement]$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The task is now to find formulae for $\VarIndexBuffer$ and $\VarIndexElement$ in terms of $i$.