\HdrGrowthArrayImpl

Indexing a growth array is slower and more complex than indexing a dynamic array. However, this does not mean that accessing data of a growth array has to be slower than accessing that of a dynamic array. Refer to Sections [Iterating] and [Copying to an array] to learn how to quickly access growth arrays' data.

Despite growth arrays' relatively poor indexing performance, I include this section for two reasons. 1) Dynamic arrays are indexed frequently. In order for growth arrays to be a viable replacement for them, it should be possible to index growth arrays too. 2) I wish to show that it is possible to index growth arrays in constant time.

The first algorithm I will demonstrate is a na\"{i}ve implementation that runs in logarithmic time:

\begin{algorithm}
	\begin{algorithmic}
		\Function{$\FuncGetItem$}{$\VarList, index$}
			\State $\VarIndex \gets index$
			\For{$\VarBuffer \TextIn \VarList.\FieldTail$}
				\If{$\VarIndex < \VarBuffer.\FieldLength$}
					\State \Return $\VarBuffer[\VarIndex]$
				\EndIf
				\State $\VarIndex \gets \VarIndex - \VarBuffer.\FieldLength$
			\EndFor
			\State \Return $\VarList.\FieldHead[\VarIndex]$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

I know that this algorithm runs in $O(\log n)$ time since it was shown earlier that the size of the tail, $\VarNumItemsTail$, equals $\VarUseful$, and (from Lemma \ref{lem:VarUsefulIsOLogN}) that $\VarUseful = O(\log n)$. Aside from iteration over the tail, all statements run in constant time.

TODO: The following needs polish

Although I have an $O(1)$ algorithm, I present this algorithm because 1) it is easier to understand and 2) the other algorithm is only fast for certain values of $\VarGrowthFactor$. [More]

Before I present the constant time algorithm, I must establish [a mathematical foundation for the code]. I note that every valid index $i$ can also be represented by an ordered pair [TODO: intro vars for these] [beta/varepsilon?] $(I_B, I_E)$, where $I_B$ represents the index of the buffer within the tail, and $I_E$ represents the index of the item within the buffer. Once these values are determined, the desired item is easily found via [code or math?] $\VarList.\FieldTail[I_B][I_E]$. [I will let $I_B = \VarList.\FieldTail.\FieldSize$ [TODO: Introduce Tsize?] mean that the buffer is $\VarList.\FieldHead$.]

I now derive formulas for $I_B$ and $I_E$ in terms of $i$ [and g and c_0?]. $I_B$ is just the index of the last buffer when $i$ elements are added, or $\VarList.\FieldTail.\FieldSize - 1$
