\HdrDynArrayImpl

I will implement appending for dynamic arrays first. Let $\VarList$ be a dynamic array. The following definitions are used in the code:

\begin{description}
	\item[initial capacity] Denoted by $\VarInitCapacity$. The capacity of an empty dynamic array.\\
	{\HdrAssumptions} $\VarInitCapacity$ is an integer, $\VarInitCapacity > 0$
	\item[growth factor] Denoted by $\VarGrowthFactor$. The factor by which the current capacity is multiplied to get the new capacity when $\VarList$ is non-empty and grows.\\
	{\HdrAssumptions} $\VarGrowthFactor\VarInitCapacity \geq \VarInitCapacity + 1$
\end{description}

\begin{algorithm}
	\begin{algorithmic}[1]
		\Procedure{$\FuncAppend$}{$L, item$}
			\If{$\VarList.\FieldFull$}
				\State $\VarList.\FuncGrow()$
			\EndIf
			
			\State $\VarList.\FieldHead[\VarList.\FieldHeadSize] \gets item$
			\State $\VarList.\FieldSize \gets \VarList.\FieldSize + 1$
		\EndProcedure
		\Statex
		\Procedure{$\FuncGrow$}{$L$}
			\State $new\ buf \gets \FuncNewArray(\VarList.\FieldSize \times \VarGrowthFactor)$
			\State $\FuncArrayCopy(\VarList.\FieldBuffer, new\ buf, \VarList.\FieldSize)$
			\State $\VarList.\FieldBuffer \gets new\ buf$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\HdrTimeComplex

Before I analyze the time complexity of $\FuncAppend$, I consider a different method for measuring its cost. Suppose I start with an empty collection and $n$ elements are appended. How many times is an element stored in an array? I will term the answer to this question the \textbf{write cost} of $n$ appends, and denote it $\FuncWrites(n)$.

In the code for $\FuncAppend$, one array store is performed unconditionally, so it is apparent that $\FuncWrites(n) \geq n$ after $n$ appends. However, $\FuncGrow$ also does some writing, so in order to find a precise formula for $\FuncWrites(n)$, I need to analyze when $\FuncGrow$ is called. To do this, I use the following lemma:

\begin{lemma}
\label{lem:CapacitySeq}
	Let $\VarList$ by a dynamic array. Let its \textbf{capacity sequence}, $\VarCapacitySeq$, be the range of values for $\VarList.\FieldCapacity$ as $n$ items are appended. For $n = 0$, trivially $\VarCapacitySeq = (\VarInitCapacity)$. For $n > 0$,
	\begin{align*}
	\VarCapacitySeq = \VarInitCapacity,\ \VarGrowthFactor\VarInitCapacity,\ \VarGrowthFactor^2\VarInitCapacity,\ \ldots\ \VarGrowthFactor^{\max(\ExprMessy, 0)}\VarInitCapacity
	\end{align*}
\end{lemma}

\begin{proof}
	I use the following properties of dynamic arrays:
	\begin{enumerate}
		\item The capacity of an empty dynamic array is $\VarInitCapacity$.
		\item The capacity of a dynamic array can only grow by $\VarGrowthFactor$.
		\item The capacity is as small as possible. Put formally, if $\VarCapacitySeq_i$ is the capacity for $n$ items, then $\VarCapacitySeq_i \geq n$ but $n > \VarCapacitySeq_{i - 1}$. (By convention, $\VarCapacitySeq_{-1} = 0$.)
	\end{enumerate}
	Assumption (1) immediately shows $\VarCapacitySeq_0 = \VarInitCapacity$. Assumption (2) shows that if $\VarGrowthFactor^i\VarInitCapacity$ is the current capacity, then $\VarGrowthFactor^{i + 1}\VarInitCapacity$ must be the next capacity. By induction, $\VarCapacitySeq = \left( \VarGrowthFactor^i\VarInitCapacity \right)_{i = 0}^\VarUseful$ for some whole number $\VarUseful$.
	
	The final value of the sequence, $\VarCapacitySeq_\VarUseful$, is the capacity needed for $n$ items. By assumption (3), $\VarCapacitySeq_\VarUseful \geq n > \VarCapacitySeq_{\VarUseful - 1}$. Consider the case when $n > \VarInitCapacity$: it must be true that $\VarCapacitySeq_\VarUseful > \VarInitCapacity$, so $\VarUseful \geq 1$. Since $\VarUseful - 1 \neq 0$, $\VarCapacitySeq_\VarUseful = \VarGrowthFactor^\VarUseful\VarInitCapacity$ and $\VarCapacitySeq_{\VarUseful - 1} = \VarGrowthFactor^{\VarUseful - 1}\VarInitCapacity$. Then
	\begin{align*}
	\VarGrowthFactor^\VarUseful\VarInitCapacity &\geq n > \VarGrowthFactor^{\VarUseful - 1}\VarInitCapacity\\
	\VarGrowthFactor^\VarUseful &\geq \frac{n}{\VarInitCapacity} > \VarGrowthFactor^{\VarUseful - 1}\\
	\VarUseful &\geq \log_{\VarGrowthFactor} n - \log_{\VarGrowthFactor} \VarInitCapacity > \VarUseful - 1\\
	\end{align*}
	Since $\VarUseful$ is an integer,
	\begin{align*}
	\VarUseful &= \ExprMessy
	\end{align*}
	Now consider the case when $n \leq \VarInitCapacity$. By assumption (3), $n > \VarCapacitySeq_{\VarUseful - 1}$. $\VarUseful - 1$ must then equal $-1$, since any other value would imply $n > \VarCapacitySeq_{\VarUseful - 1} \geq \VarInitCapacity$. Thus $\VarUseful = 0$.
	
	It was shown $\VarUseful \geq 1 \geq 0$ for the first case, and it can be shown $\ExprMessy \leq 0$ for the second case. Then, a general formula for $\VarUseful$ is as follows:
	\begin{align*}
	\VarUseful &= \max(\ExprMessy, 0)
	\end{align*}
	The final term in the sequence is $\VarGrowthFactor^\VarUseful\VarInitCapacity = \VarGrowthFactor^{\max(\ExprMessy, 0)}\VarInitCapacity$, completing the proof.
\end{proof}

\begin{corollary}
\label{coro:GrowthSeq}
	Let the \textbf{growth sequence}, $\VarGrowSeq$, of $\VarList$ be the sizes for which $\FuncGrow$ is called when $n$ items are appended. Then $\VarGrowSeq = \VarCapacitySeq \setminus \left\{ \VarCapacitySeq_\VarUseful \right\}$.
\end{corollary}

\begin{proof}
	If $\VarCapacitySeq_i$ exists and $i \geq 1$, then clearly $\FuncGrow$ must have been called when the size was $\VarCapacitySeq_{i - 1}$, so $\VarCapacitySeq_{i - 1} \in \VarGrowSeq$. Then $\VarGrowSeq$ contains every term in $\VarCapacitySeq$ except for the last, $\VarCapacitySeq_\VarUseful$, as stated by the corollary.
\end{proof}
[make corollary]
If $\VarCapacitySeq_i$ exists and $i \geq 1$, then clearly $\FuncGrow$ must have been called when the size was $\VarCapacitySeq_{i - 1}$. Then the \textbf{growth sequence}, the sizes for which $\FuncGrow$ is called when $n$ items are appended, is $\VarCapacitySeq$ with the last term removed:
\begin{align*}
\VarGrowSeq = \VarCapacitySeq \setminus \left\{ \VarCapacitySeq_\VarUseful \right\}
\end{align*}

When $\FuncGrow$ is called and the current size is $\VarGrowSeq_i$, the algorithm copies $\VarGrowSeq_i$ items. Then the total number of items copied when $n$ items are appended is:
\begin{align*}
\sum_i {\VarGrowSeq_i} &= \VarInitCapacity + \VarGrowthFactor\VarInitCapacity + \ldots + \VarGrowthFactor^{\VarUseful - 1}\VarInitCapacity\\
&= \left( \frac{\VarGrowthFactor^{\VarUseful} - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity
\end{align*}
Counting the writes made for each item by $\FuncAppend$, an explicit formula for $\FuncWrites(n)$ is as follows:
[ref1]
\begin{align*}
\FuncWrites(n) = n + \left( \frac{\VarGrowthFactor^\VarUseful - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity
\end{align*}
Now, my goal is to approximate $\FuncWrites(n)$ with $\sim$. To make is easier to do so, I will asymptotically bound $\VarGrowthFactor^\VarUseful$ which depends on $n$.

\begin{lemma}
\label{lem:ToVarUsefulPowerBounds}
	For $n > \VarInitCapacity$, $\dfrac n \VarInitCapacity \leq \VarGrowthFactor^\VarUseful < \dfrac {\VarGrowthFactor{n}} \VarInitCapacity$.
\end{lemma}

\begin{proof}
	It was shown in Lemma \ref{lem:CapacitySeq} that if $n > \VarInitCapacity$, $\VarUseful = \ExprMessy \geq 1$.  Now note that $\VarUseful$ may also be written as $\ExprMessyAlt$. Then
	\begin{align*}
	\ExprMessyAltInner \leq \VarUseful &< \ExprMessyAltInner + 1\\
	\frac{n}{\VarInitCapacity} \leq \VarUseful &< \frac{\VarGrowthFactor{n}}{\VarInitCapacity}
	\end{align*}
	as desired.
\end{proof}

Now, I proceed to asymptotically bound $\FuncWrites(n)$.
\begin{align*}
\FuncWrites(n) &= n + \left( \frac{\VarGrowthFactor^\VarUseful - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity\\
n + \left( \frac{n / \VarInitCapacity - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity \FluteLeq \FuncWrites(n) &\FluteLess n + \left( \frac{\VarGrowthFactor{n} / \VarInitCapacity - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity\\
\left( \frac{\VarGrowthFactor}{\VarGrowthFactor - 1} \right) n - \left( \frac{\VarInitCapacity}{\VarGrowthFactor - 1} \right) \FluteLeq \FuncWrites(n) &\FluteLess \left( \frac{2\VarGrowthFactor - 1}{\VarGrowthFactor - 1} \right) n - \left( \frac{\VarInitCapacity}{\VarGrowthFactor - 1} \right)\\
\left( \frac{\VarGrowthFactor}{\VarGrowthFactor - 1} \right) n \FluteLeq \FuncWrites(n) &\FluteLess \left( \frac{2\VarGrowthFactor - 1}{\VarGrowthFactor - 1} \right) n
\end{align*}
\HdrSpaceComplex

I wish to find the space allocated when $n$ items are appended to a dynamic array. I call this quantity the \textbf{space cost}, denote it $\FuncSpace(n)$, and define it as the total length of buffers allocated by $n$ $\FuncAppend$ calls. Now, I derive a formula for $\FuncSpace(n)$.

First, from the definition of $\VarList.\FieldCapacity$, note that a dynamic array's capacity is the length of the buffer it stores its items in. Then a buffer of length $c$ is allocated at some point if and only if $c \in \VarCapacitySeq$. Then the total length of those buffers is
\begin{align*}
\FuncSpace(n) &= \sum_i {\VarCapacitySeq_i}\\
&= \VarInitCapacity + \VarGrowthFactor\VarInitCapacity + \VarGrowthFactor^2\VarInitCapacity + \ldots + \VarGrowthFactor^\VarUseful\VarInitCapacity\\
&= \left( \frac{\VarGrowthFactor^{\VarUseful + 1} - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity
\end{align*}
Using Lemma \ref{lem:ToVarUsefulPowerBounds} again, I asymptotically bound $\FuncSpace(n)$:
\begin{align*}
\left( \frac{\VarGrowthFactor{n} / \VarInitCapacity - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity \FluteLeq \FuncSpace(n) &\FluteLess \left( \frac{\VarGrowthFactor^2{n} / \VarInitCapacity - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity\\
\left( \frac{\VarGrowthFactor}{\VarGrowthFactor - 1} \right) n - \left( \frac{\VarInitCapacity}{\VarGrowthFactor - 1} \right) \FluteLeq \FuncSpace(n) &\FluteLess \left( \frac{\VarGrowthFactor^2}{\VarGrowthFactor - 1} \right) n - \left( \frac{\VarInitCapacity}{\VarGrowthFactor - 1} \right)\\
\left( \frac{\VarGrowthFactor}{\VarGrowthFactor - 1} \right) n \FluteLeq \FuncSpace(n) &\FluteLess \left( \frac{\VarGrowthFactor^2}{\VarGrowthFactor - 1} \right) n
\end{align*}