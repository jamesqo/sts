\HdrDynArrayImpl

I will implement appending for dynamic arrays first. Let $\VarList$ be a dynamic array. The following definitions are used in the code:

\begin{description}
	\item[initial capacity] Denoted by $\VarInitCapacity$. The capacity of a dynamic a array when one item is appended to it.\\
	{\HdrNote} The capacity of any dynamic array with size zero should be zero.
	\item[growth factor] Denoted by $\VarGrowthFactor$. The factor by which the current capacity is multiplied to get the new capacity when $\VarList$ grows.
\end{description}

\begin{algorithm}
	\begin{algorithmic}[1]
		\Procedure{$\FuncAppend$}{$L, item$}
			\If{$\VarList.\FieldFull$}
				\State $\VarList.\FuncGrow()$
			\EndIf
			
			\State $\VarList.\FieldHead[\VarList.\FieldHeadSize] \gets item$
			\State $\VarList.\FieldSize \gets \VarList.\FieldSize + 1$
		\EndProcedure
		\Statex
		\Procedure{$\FuncGrow$}{$L$}
			\If{$\VarList.\FieldEmpty$}
				\State $\VarList.\FieldBuffer \gets \FuncNewArray(\VarInitCapacity)$
			\Else
				\State $new\ buf \gets \FuncNewArray(\VarList.\FieldSize \times \VarGrowthFactor)$
				\State $\FuncArrayCopy(\VarList.\FieldBuffer, new\ buf, \VarList.\FieldSize)$
				\State $\VarList.\FieldBuffer \gets new\ buf$
			\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\HdrTimeComplex

Before I analyze the time complexity of $\FuncAppend$, I consider a different method for measuring its cost. Suppose I start with an empty collection and $n$ elements are appended. How many times is an element stored in an array? I will term the answer to this question the \textbf{write cost} of $n$ appends, and denote it $\FuncWrites(n)$.

In the code for $\FuncAppend$, one array store is performed unconditionally, so it is apparent that $\FuncWrites(n) \geq n$ after $n$ appends. However, $\FuncGrow$ also does some writing, so in order to find a precise formula for $\FuncWrites(n)$, I need to analyze when $\FuncGrow$ is called. To do this, I use the following lemma:

\begin{lemma}
\label{lem:CapacitySeq}
	Let $\VarList$ by a dynamic array. Let its \textbf{capacity sequence}, $\VarCapacitySeq$, be the capacities $\VarList$ takes on as $n$ items are appended. For $n = 0$, trivially $\VarCapacitySeq = (0)$. For $n > 0$,
	\begin{align*}
	\VarCapacitySeq = 0,\ \VarInitCapacity,\ \VarGrowthFactor\VarInitCapacity,\ \VarGrowthFactor^2\VarInitCapacity,\ \ldots\ \VarGrowthFactor^{\max(\lceil \log_{\VarGrowthFactor} n - \log_{\VarGrowthFactor} \VarInitCapacity \rceil, 0)}\VarInitCapacity
	\end{align*}
\end{lemma}

\begin{proof}
	We use the following properties of dynamic arrays:
	\begin{enumerate}
		\item The capacity of an empty dynamic array is $0$.
		\item The capacity of a dynamic array with one item is $\VarInitCapacity$.
		\item Once it is non-empty, the capacity of a dynamic array can only grow by $\VarGrowthFactor$.
		\item The capacity is only as large as it needs to be. That is, if $\VarCapacitySeq_i$ is the capacity for size $n$, then $n > \VarCapacitySeq_{i - 1}$. ($i > 1$ since $n > 0$, so $\VarCapacitySeq_{i - 1}$ must be defined.)
	\end{enumerate}
	Assumptions (1) and (2) immediately show $\VarCapacitySeq_1 = 0$ and $\VarCapacitySeq_2 = \VarInitCapacity$. Assumption (3) shows that if $\VarGrowthFactor^i\VarInitCapacity$ is the current capacity, then $\VarGrowthFactor^{i + 1}\VarInitCapacity$ must be the next capacity. By induction, the rest of the sequence is $\left( \VarGrowthFactor^i\VarInitCapacity \right)_{i = 1}^\VarUseful = \left( \VarCapacitySeq_i \right)_{i = 3}^{\VarUseful + 2}$ for some integer $\VarUseful$.
	
	By assumption (4), $\VarCapacitySeq_{\VarUseful + 2} \geq n > \VarCapacitySeq_{\VarUseful + 1}$. Supposing $n > \VarInitCapacity$, from (4) again I know that the rest of the sequence contains at least one term. Then $\VarUseful \geq 1$, so $\VarCapacitySeq_{\VarUseful + 2} = \VarGrowthFactor^\VarUseful\VarInitCapacity$ and $\VarCapacitySeq_{\VarUseful + 1} = \VarGrowthFactor^{\VarUseful - 1}\VarInitCapacity$. I can now derive $\VarUseful$:
	\begin{align*}
	\VarGrowthFactor^\VarUseful\VarInitCapacity &\geq n > \VarGrowthFactor^{\VarUseful - 1}\VarInitCapacity\\
	\VarGrowthFactor^\VarUseful &\geq \frac{n}{\VarInitCapacity} > \VarGrowthFactor^{\VarUseful - 1}\\
	\VarUseful &\geq \log_{\VarGrowthFactor} n - \log_{\VarGrowthFactor} \VarInitCapacity > \VarUseful - 1\\
	\end{align*}
	Since $\VarUseful$ is an integer,
	\begin{align*}
	\VarUseful &= \big\lceil \log_{\VarGrowthFactor} n - \log_{\VarGrowthFactor} \VarInitCapacity \big\rceil
	\end{align*}
	If $n \leq \VarInitCapacity$, then necessarily $\VarCapacitySeq_{\VarUseful + 2} = \VarGrowthFactor^\VarUseful\VarInitCapacity$ is empty and $\VarUseful = 0$. Since $\VarUseful \geq 1$ for the previous case, we may obtain a general formula for $\VarUseful$ like so:
	\begin{align*}
	\VarUseful &= \max(\lceil \log_{\VarGrowthFactor} n - \log_{\VarGrowthFactor} \VarInitCapacity \rceil, 0)
	\end{align*}
	The final term in the sequence is $\VarGrowthFactor^\VarUseful\VarInitCapacity = \VarGrowthFactor^{\max(\lceil \log_{\VarGrowthFactor} n - \log_{\VarGrowthFactor} \VarInitCapacity \rceil, 0)}\VarInitCapacity$, completing the proof.
\end{proof}

[make lemma]
Now, consider that to grow by $\VarGrowthFactor$, $\FuncGrow$ must be called. So $\VarGrowthFactor^i\VarInitCapacity$ being present in $S_C$ means $\FuncGrow$ was called at size $\VarGrowthFactor^{i - 1}\VarInitCapacity$ for $i \geq 1$. Then $\FuncGrow$ was called at the sizes
\begin{align*}
\VarGrowSeq = 0,\ \VarInitCapacity,\ \VarGrowthFactor\VarInitCapacity,\ \VarGrowthFactor^2\VarInitCapacity,\ \ldots\ \VarGrowthFactor^{\VarUseful - 1}\VarInitCapacity
\end{align*}
Each time $\FuncGrow$ is called, $s$ items are copied where $s$ is the current size of the dynamic array. Then the total number of items copied for $n$ appends is
\begin{align*}
\sum_{s \in \VarGrowSeq} s &= 0 + \VarInitCapacity + \VarGrowthFactor\VarInitCapacity + \ldots + \VarGrowthFactor^{\VarUseful - 1}\VarInitCapacity\\
&= \left( \frac{\VarGrowthFactor^{\VarUseful} - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity
\end{align*}
Counting the writes made for every item in $\FuncAppend$, I finally find an explicit formula for $\FuncWrites(n)$.
[ref1]
\begin{align*}
\FuncWrites(n) = n + \left( \frac{\VarGrowthFactor^\VarUseful - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity
\end{align*}
This expression looks clean at a glance, but $\VarUseful$ implicitly depends on $n$ and uses the ceiling function and logarithms. To make it easier to analyze, I will asymptotically bound this expression.

[ref2]
First I note that $\log_{\VarGrowthFactor} k \leq \lceil \log_{\VarGrowthFactor} k \rceil < \left( \log_{\VarGrowthFactor} k \right) + 1$ for any $k > 0$, so $k \leq \VarGrowthFactor^{\lceil \log_{\VarGrowthFactor} k \rceil} < \VarGrowthFactor{k}$. Since $\VarUseful = \left\lceil \log_{\VarGrowthFactor} \frac{n}{\VarInitCapacity} \right\rceil$, $\frac n \VarInitCapacity \leq \VarGrowthFactor^\VarUseful < \frac {\VarGrowthFactor{n}} \VarInitCapacity$. Then
\begin{align*}
\FuncWrites(n) &= n + \left( \frac{\VarGrowthFactor^\VarUseful - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity\\
n + \left( \frac{n / \VarInitCapacity - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity \leq \FuncWrites(n) &< n + \left( \frac{\VarGrowthFactor{n} / \VarInitCapacity - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity\\
n + \left( \frac{n - \VarInitCapacity}{\VarGrowthFactor - 1} \right) \leq \FuncWrites(n) &< n + \left( \frac{\VarGrowthFactor{n} - \VarInitCapacity}{\VarGrowthFactor - 1} \right)\\
n + \left( \frac{n - \VarInitCapacity}{\VarGrowthFactor - 1} \right) \RelLessEqual \FuncWrites(n) &\RelLess n + \left( \frac{\VarGrowthFactor{n} - \VarInitCapacity}{\VarGrowthFactor - 1} \right)\\
\left( \frac{\VarGrowthFactor}{\VarGrowthFactor - 1} \right) n \RelLessEqual \FuncWrites(n) &\RelLess \left( \frac{2\VarGrowthFactor - 1}{\VarGrowthFactor - 1} \right) n
\end{align*}

\HdrSpaceComplex

I wish to find the space allocated when $n$ items are appended to a dynamic array. I call this quantity the \textbf{space cost}, denote it $\FuncSpace(n)$, and define it as the total length of arrays allocated by $n$ $\FuncAppend$ calls. I now derive a formula for $\FuncSpace(n)$.

From \ref{lem:CapacitySeq}, I know the capacity sequence of $\VarList$. Dynamic arrays also have the property that $c \in \VarCapacitySeq$ iff an array of length $c$ was allocated. Then the total length of arrays allocated is

\begin{align*}
\FuncSpace(n) &= \sum_{c \in \VarCapacitySeq} c\\
&= 0 + \VarInitCapacity + \VarGrowthFactor\VarInitCapacity + \VarGrowthFactor^2\VarInitCapacity + \ldots + \VarGrowthFactor^\VarUseful\VarInitCapacity\\
&= \left( \frac{\VarGrowthFactor^{\VarUseful + 1} - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity
\end{align*}

Using the identity in [ref2] again, I asymptotically bound $\FuncSpace(n)$:

\begin{align*}
\left( \frac{\VarGrowthFactor{n} / \VarInitCapacity - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity \leq \FuncSpace(n) &< \left( \frac{\VarGrowthFactor^2{n} / \VarInitCapacity - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity\\
\left( \frac{\VarGrowthFactor{n} / \VarInitCapacity - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity \RelLessEqual \FuncSpace(n) &\RelLess \left( \frac{\VarGrowthFactor^2{n} / \VarInitCapacity - 1}{\VarGrowthFactor - 1} \right) \VarInitCapacity\\
\left( \frac{\VarGrowthFactor}{\VarGrowthFactor - 1} \right) n \RelLessEqual \FuncSpace(n) &\RelLess \left( \frac{\VarGrowthFactor^2}{\VarGrowthFactor - 1} \right) n
\end{align*}